# 1/6

## 스프링이 필요한 이유

---

- 웹 서비스 아키텍처 WAS, Web Server, Web Application
1. **Web Server**
    
    프록시, 로드밸런스 역할 등 - 엔진X, forward proxy, reverse proxy 등
    
2. **WAS(Web Application Server)**
    
    웹 어플리케이션 실행 환경 - 톰캣
    
3. **Web Application**
    
    작성하는 스프링 코드
    

---

1. **spring을 배우는 이유**
    
    JS가 사용률 가장 많음 ← 백엔드 프론트를 둘다 할수 없음
    
    스프링은 복잡하고 무거움
    
    전자정보 표준 프레임워크 = 스프링, 마이바티스
    
    객체 결합도 낮춤, 역할 분리 등 → 기존 서블릿 방식에서는 힘듦
    
    AOP
    
    유지보수 쉬움
    
2. **spring**
    
    자바 기반 코드 작성 프레임워크
    
    장) POJO 기반 구성
    
    코드 개발시 개발자가 특정 라이브러리 등에 종속적이지 않음
    
    프레임워크 특유 문법을 모르고 자바만 알아도 코드 작성이 가능 - 객체지향 설계의 구현 가능
    
    IoC: ~를 해야한다 방법론
    
    DI: 을 구현하는 구현체
    
3. **서블릿(Servlet)**
    
    자바로 웹 요청, 응답 처리하는 기술
    
    http → 자바 객체 변환
    
    한계: 요청 처리+ 비즈니스 로직+공통 로직이 섞임
    
    객체 직접 생성해줘야 하고 확장성 저하
    
4. **서블릿 컨테이너**
    
    WAS에 존재 - 해당 컨테이너를 통해 디스패처 컨테이너 관리
    
5. **장점**
    1. **POJO 기반의 구성**
        
        특정 프레임워크에 종속적이지 않음
        
        → 객체지향 O
        
    2. **IoC(Inversion of Control)**
        
        객체의 생성, 생명 주기 등을 개발자가 작성하는게 아니라 프레임워크가 위임하는 것
        
        언제 생성시킬지, 언제 소멸시킬지 등을 결정하는 런타임 시스템
        
        (객체 그래프를 런타임에 구성)
        
        spring IoC Container 문서 보기
        
    3. **DI(Dependency Injection)**
        
        IoC 내용을 구체적으로 구현하는 내용이 DI - 의존성 주입(아래 필드 주입, 세터 주입, 생성자 주입)
        
        디자인 패턴: 어떤 문제를 해결하기 위해 공식처럼 만들어둔 방법론
        
        언어가 중요하진 않고 구체적 명세가 존재
        
        IoC를 구현하는 디자인 패턴이 DI
        
    4. **컴포넌트 스캔과 자동 의존관계 설정**
        
        @Autowired
        
        생성자 자동 주입
        
    5. **의존성 주입의 방법**
        1. **생성자 주입-autowired(지금은 안씀)**
            
            ```java
            public class A {
                private B b;
            
                public A(B b) {
                    this.b = b;
                }
            }
            ```
            
        2. **setter 주입**
            
            ```java
            public class A {
                private B b;
            
                public void setB(B b) {
                    this.b = b;
                }
            }
            ```
            
        3. **인터페이스 주입**
            
            ```java
            public interface BInjection {
                void inject(B b);
            }
            
            public A implements BInjection {
                private B b;
            
                @Override
                public void inject(B b) {
                    this.b = b;
                }
            }
            ```
            
    6. **AOP(관점 지향 프로그래밍)**
        
        관심사 분리
        
        코드 구현에 있어서 관리로직/비즈니스 로직이 있는데, 이걸 구분해서 한 코드 내에서 분리 가능-코드 길이 짧아지고 유지보수 쉬워짐
        
        어노테이션: 코드에 어떤 관리 로직 적용할지 표시
        
        어노테이션 설정 관리 = 관리 로직 분리
        
        객체/클래스/메서드 별로 붙일 수 있음
        
        어디에 붙냐에 따라 우선순위가 달라짐
        
        트랜잭션: DB 작업 성공/실패를 하나로 묶음
        
        변경이 일어날 때 하나씩 변경할 필요가 없음
        
    
    **h.  WAS에 종속적이지 않음**
    
    톰캣 말고 다른 와스를 사용 가능
    
    대신 서블릿 표준을 구현한 와스여야 함 - 해당 와스는 서블릿(서블릿 컨테이너)을 구현한 와스여야 스프링에서 사용할 수 있음
    
    !와스의 버전에는 종속적임 - 스프링부트가 아닌 스프링 프레임워크를 쓴다면 톰캣을 설치해야 함(버전이 유사해야 함)
    

추가

스프링의 객체 생성 방법(Spring IoC Container)

- 객체 생성은 프로그램 실행시 하나 생성 → 삭제는 없음(프로그램 죽을 때)
- 클래스 하나당 객체 하나 → 스프링 bin으로 등록
- autowired가 붙은 객체에 IoC Container를 통해 생성자 주입 등록

→ 이런걸 Spring 의존성 주입이라고 함

singleton pattern → private final(무조건 이렇게 선언해야 함)

서비스의 method 단에서는 가능

(stack메모리에서 별개로 관리하기 때문에 new를 사용 가능 - 값을 넣어주는 등 일련의 활동 가능)

---

https://velog.io/@ohzzi/Spring-DIIoC-IoC-DI-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0
